\chapter{Literature Review}
\label{literatureReview}

\section{Wireless Sensor Networks}
A WSN is a network of sensor nodes with the purpose of collecting sensor measurements from the target environment, and sending these measurements over the radio. One classic example is environmental monitoring, where sensor nodes are distributed over the area of interest measuring some properties there; such as temperature.
Sensor nodes can be used for continuous sensing, event detection, location sensing and local control of actuators. 

There are 5 types of WSNs \cite{wsnSurvey1}.
Multimedia WSN \cite{wsnSurvey3}.

The evolution of wireless sensor networks is largely driven by a set of emerging applications. The smart grid is intended to improve the electrical power grid and save considerable amounts of energy for society as a whole. Building and home automation improves the quality of indoor environments in terms of temperature, air quality, and lighting, while saving energy in the process. Industrial automation improves the quality of industrial processes. Smart cities allow new services inside increasingly populated cities such as automatic parking management and pollution monitoring. Wireless sensors are an integral part of all these applications \cite{beyondInteroperability}

\subsection{Overview (Application Scenarios for WSNs}
The application can be categorised into 5; military, environment, health, home and other commercial areas \cite{wsnSurvey2}

\section{Maximize Lifetime and Minimizing Energy}
-through routing protocol (clustering), adjust transmission range, MAC sleep awake 
-energy harvesting?

A precise definition of a WSN lifetime is application dependent: some application might tolerate a loss of considerable number of nodes, while for other applications a loss of even a node is critical. Network lifetime is defined as the length of time until the first battery expends its available energy. Although network lifetime is strongly related to minimal remaining energy of all the nodes, the best network lifetime could not be achieved by only maximized the minimal remaining energy of all the nodes. Usually place too heavy burden of forwarding data on a couple of key nodes so that these nodes drain out their batteries quickly which shortens lifetime of the WSN \cite{erapl}.

Wireless systems are often powered by batteries whereby the system's energy consumption determines its lifetime.

Prolonging network lifetime and saving energy are two critical issues for WSNs. Routing protocols are needed in which data packets are transmitted via multi-hop manner to reach the sink or destination. Therefore, it is critical for a WSN to run effectively to design an energy-efficient routing algorithm in which battery energy is expended efficiently while the WSN has a longer lifetime. The best network lifetime could not be achieved by only considering the minimal remaining energy of all the nodes in the WSN. Combining the minimal remaining energy and total energy consumption plays a key role in prolonging network lifetime of a WSN \cite{erapl}.

1. MAC - multichannel
2. Routing
3. Transmit power control

\subsection{MAC Protocols}
Main causes of energy consumption. Collisions - may happen when a node is within the transmission range of two or more nodes that are simultaneously transmitting so that it does not capture any frame. The energy drained in the transmission and reception of collided frames is just wasted. Overhearing - happens when a node drains energy receiving irrelevant packets or signals. Idle listening - when a node does not know when it will be the receiver of a frame; the node keeps its radio on while listening to the channel waiting for potential data frames. The amount of energy wasted whilst the radio is on is considerable even when it is neither receiving nor transmitting frames. Nodes waste considerable amounts of energy as they keep their radios on for large time intervals while listening to an idle channel. Energy-efficient MACs should make nodes sleep for long periods of time instead of enabling them to be permanently active. Put nodes to sleep as long as possible while avoiding deafness and reducing overhearing and overheI've received from:ad. In order to extend nodes lifetime, applications need to save more energy by lowering the duty cycle. Lowering the duty cycle implies putting nodes in sleep mode for larger periods, which means extending the check interval. \cite{macsurvey}

A major problem is deploying WSNs in their dependence on limited battery power. A main design criterion is to extend the lifetime of the network without jeopardizing reliable and efficient communications from sensor nodes to the other nodes as well as data sinks. One solution is the medium access control (MAC). The prime role of the MAC is to coordinate access to and transmission over a medium common to several nodes. The common medium is the wireless channel. Since the radio is controlled by the MAC, the MAC is central in optimizing the WSN's lifetime. The aim of a WSN design is to guarantee its longevity under the given energy and complexity constraints. The MAC plays a central part in this design since it controls the active and sleeping state of each node. The MAC protocols hence needs to trade longevity, reliability, fairness, scalability and latency; throughput is rarely a primary design factor. \cite{macsurvey}

Many energy-efficient MAC protocols have been proposed to improve the lifetime of sensor networks by reducing the energy consumed by idle listening and overhearing. The idle listening problem refers to a node listening to the channel even though there are no radio transmissions to receive. The overhearing problem refers to a node receiving a packet it is not intended to receive \cite{pwmac}. 

\subsection{Routing Protocols}
A routing algorithm termed Energy-efficient Routing Algorithm to Prolong Lifetime (ERAPL) is proposed. A data gathering sequence (DGS) used to avoid and eliminate mutual transmission and loop transmission among nodes (node is only allowed to transmit to its neighboring node in forward direction only to avoid loop), is constructed and each node proportionally transmit traffic to the links confined in the DGS. The main task of the ERAPL is to determine the optimal outgoing traffic to maximize the network lifetime for a given WSN. In addition, a mathematical programming model, in which minimal remaining energy of nodes and total energy consumptions are included, is presented to optimized network lifetime. ERAPL is a centralised algorithm and runs at the sink; sink knows the topology of the WSN. Sink inform all the nodes in the WSN of a packet that contains the constructed DGS which guides all the nodes to transmit traffic to their respective neighbors so that mutual transmission among nodes and route loop is avoided and accordingly energy is saved. ERAPL can improve network lifetime while expending energy efficiently by constructing a DGS and finding the optimal outgoing traffic proportions for all the nodes to distribute packets to their respective neighbouring nodes \cite{erapl}. 

\subsection{Transmit Power Control}
Power control to improve energy efficiency of the wireless sensor network. Whilst it is a useful tool to control traffic flows, congestion and interference levels, the power savings due reduced transmission powers are negligible since the radio's power consumption is in the range of the transmit power levels typically employed for embedded WSN nodes. \cite{macsurvey}

\subsection{Energy Harvesting}
Energy harvesting involves nodes replenishing its energy from an energy source. Potential energy sources include solar cells, vibration, fuel cells, acoustic noise and a mobile supplier. In terms of harvesting energy from the environment, solar cell is the current mature technique that harvest energy from light. There is also work in using mobile energy supplier such as a robot to replenish energy. The robots would be responsible in charging themselves with energy and then delivering energy to nodes \cite{wsnSurvey1}.

Sparse sensor placement may result in long-range transmission and higher energy usage while dense sensor placement may result in short-range transmission and less energy consumption.

Note that different powering mechanisms are available, such as non-rechargeable battery; rechargeable battery with regular recharging (e.g. sunlight); rechargeable battery with irregular recharging (e.g. opportunistic energy scavenging); capacitive/inductive energy provision (e.g. RFPD); etc \cite{macsurvey}.

\section{Multichannel Protocol (Data Link Layer)}
In single-channel MAC protocols, all nodes are configured to use a single frequency all the time. Frequency-agile MAC protocols switch between multiple frequencies during run-time. Recent radio chips are able to switch between frequency channels fast (e.g. in less than 100$\mu$s). Multi-channel can be used to increase robustness against narrowband long-lasting and transient interference. \cite{macsurvey}

\subsection{Introduction (Solutions)}
Multichannel communication has potential benefits for wireless networks that possibly include improved resilience against external interference, reduced latency, enhanced reception rate and increased throughput. 
There have been some proposals/solutions for multichannel. These approaches focus on (the mac layer) and depending on ().

The duty cycling technique saves energy by switching nodes between awake and sleeping states. The duty cycling is an important mechanism for reducing energy consumption in sensor networks. Existing duty cycling energy-efficient MAC protocols can be categorized into two types; synchronous and asynchronous.

Radio duty cycling mechanisms can be classified into two categories; synchronous and asynchronous systems. A synchronous system is a system that requires a tight time synchronization between nodes. It uses time-scheduled communication where the network clock needs to be periodically synchronized in order for the nodes not to drift in time. Asynchronous system on the other hand, do not require synchronization but instead is a sender or receiver initiated communication. In asynchronous systems the nodes are able to self-configure without time synchronization and this can have advantages. There are many studies done in multichannel for both categories.

The sender-initiated approach, a sender transmits preamble before a packet transmission to notify the receiver of the upcoming packet. With receiver-initiated approach, in contrast, sender preambles are replaced with receiver wakeup beacons. Receiver-initiated wakeup beacons are used to avoid long sender-initiated preambles. However, a larger sender duty cycle due to idle listening until the receiver wakes up. In sender-initiated protocols, a sender often shows much larger duty cycle than a receiver, transmitting the preamble until the receiver wakes up \cite{pwmac}. To overcome this, many sender-initiated protocols use predictive wakeup in sensor network MAC protocols to enable reducing the preamble length (WiseMAC - fixing the node wakeup interval. PW-MAC - wake up according to independently generated pseudo-random scheduless).

Two main approaches; reservation-based protocols (synchronous) where it requires the knowledge of the network topology to establish a schedule that allows each node to access the channel and communicate with other nodes. It needs dependency on network topology and time synchronization. Tight synchronization to ensure a common schedule among nodes. Both knowledge of topology and strict synchronization requires large overheads. Contention-based protocols - neither global synchronization nor topology knowledge is required. Nodes compete for the use of the wireless medium and only the winner of this competition is allowed to access to the channel and transmit. In CSMA for instantce, a node having a packet to transmit first senses the channel before actually transmitting. In the case that the node finds the channel busy, it postpones its transmission to avoid interfering with the ongoing transmission. Contention-based protocols suffer from degraded performance in terms of throughput when the traffic load increases. \cite{macsurvey}

\subsection{Synchronous Systems}
-TSCH, MC-LMAC, YMAC

\subsubsection{TSCH}

\subsubsection{MC-LMAC}

\subsubsection{YMAC}

\subsection{Asynchronous Systems}
%-EM-MAC, MuChMAC, Chrysso, MiCMAC - ContikiMAC?
Recent asynchronous multi channel MAC layers are Chrysso and MiCMAC. MiCMAC is built based on ContikiMAC, the default radio duty cycling in Contiki 2.7 that works in a single channel. The details of these are explained below.

\subsubsection{ContikiMAC}
ContikiMAC radio duty cycling mechanism is the default radio duty cycling mechanism in Contiki 2.7. It uses a power efficient wake up mechanism with a set of timing constraints to allow device to keep their transceivers off. The wireless transceiver consumes as much power when passively listening for transmissions from other devices as it does when actively transmitting, so the transceiver must be completely turned off to save power. ContikiMAC keep their radios turned off for roughly 99\% of the time.  ContikiMAC uses only asynchronous mechanisms, no signalling messages, and no additional packet headers. ContikiMAC packets are ordinary link layer messages. ContikiMAC uses a fast sleep optimization, to allow receivers to quickly detect false positive wake-ups (fast sleep optimization to allow receivers to quickly go to sleep when faced with spurious radio interference), and a transmission phase-lock optimization. The idea of periodic wake-ups has been used by many protocols, such as B-MAC, X-MAC and BoX-MAC. The phase-lock optimization has been previously suggested by WiseMAC and has since been used by other protocols as well. 

ContikiMAC uses a fast sleep optimization, to allow receivers to quickly detect false-positive wake-up and a transmission phase-lock optimization, to allow run-time optimization of the energy-efficiency of transmissions. 

ContikiMAC is a radio duty cycling protocol that uses periodical wake-ups to listen for packet transmissions from neighbors. If a packet transmission is detected during a wake-up, the receiver is kept on to be able to receive the packet. UNICAST - When the packet is successfully received, the receiver sends a link layer acknowledgement. To transmit a packet, a sender repeatedly sends its packet until it receives a link layer acknowledgement from the receiver. Acknowledgement transmission is done as part of the unicast packet reception. Packets that are sent as broadcasts do not result in link layer acknowledgements. Instead, the sender repeatedly sends the packet during the full wake-up interval to ensure that all neighbors have received it. Since a broadcast transmission does not expect any link layer acknowledgement, the transmitter can turn of its radio between each packet transmission to save power.

ContikiMAC wake-up frequency of 8Hz which results in a wake-up interval of 125 ms. Radio duty cycle increase with the wake-up frequency; more wake-ups, the total power consumption of the network increase (channel check rate higher than 8Hz).

ContikiMAC wake-ups use an inexpensive Clear Channel Assessment (CCA) mechanism that uses the Received Signal Strength Indicator (RSSI) of the radio transceiver to give an indication of radio activity on the channel. If the RSSI is below a given threshold, the CCA returns positive, indicating that the channel is clear. If the RSSI is above the threshold, the CCA returns negative, indicating that the channel is in use.

\textbf{Detection - }
ContikiMAC CCAs do not reliably detect packet transmission: they only detect that the radio signal strength is above a certain threshold. The detection of a radio signal may mean that a neighbor is transmitting a packet to the receiver, that a neighbor is transmitting to another receiver, or that some other device is radiating radio energy that is being detected by the CCA mechanism. ContikiMAC must be able to discern between these events and react properly.

\textbf{Fast Sleep - }
The fast sleep optimization lets potential receivers go to sleep earlier if the CCA woke up due to spurious radio noise. Specific pattern of ContikiMAC transmissions:
	If CCA detects radio activity but the radio activity has a duration that is longer than the maximum packet length, the CCA has detected noise and can go back to sleep (if the activity period is not followed by a silence period).
	If the radio activity is followed by a silence period that is longer than the interval between two successive transmissions, the receiver can go back to sleep.
	If the activity period is followed by a silence period of the correct length, followed by activity but no start of packet could be detected, the receiver can go back to sleep.
	
\textbf{Transmission Phase-Lock - }
A sender can learn of a receiver's wake-up phase by making note of the time at which it saw a link layer acknowledgement from the receiver. The sender can assume that the reception of a link layer acknowledgement means that the sender has successfully transmitted a packet within the receiver's wake-up window and thus the sender has found the receiver's wake-up phase. The sender can commence its successive transmissions to this receiver just before the receiver is expected to be awake. The transmission will be significantly shorter than a normal transmission, because it occurs just before the neighbor is expected to be awake. Reducing the length of the transmission thus reduces radio congestion.
	The phase-lock mechanism is implemented as a separate module from ContikiMAC.
	The phase-lock mechanism maintains a list of neighbors and their wake-up phases.
	
Fast sleep and phase-lock optimizations significantly reduce power consumption. This is because of a phase-locked transmission being shorter than non-phased-locked transmissions, leading both to less energy being spent on transmissions and to less radio congestion \cite{contikimac}.

\subsubsection{MiCMAC}

\subsubsection{Chrysso}

\subsection{Comparison and Discussion}

\section{Routing Protocols (Network Layer Protocols)}
The network layer is responsible in routing the data across the network from the source to the destination. Routing protocols in WSNs differs from traditional routing protocols depending on the Operating System.
Contiki provides IP communication in both IPv4 and IPv6. However, as sensors have a small amount of memory, uIP, which is a small RFC-compliant TCP/IP stack that makes it possible to communicate over the Internet \cite{contikiDoc, contikiUIP}. uIP () to reduce the resources it requires.
uIP implementation is designed to have only the absolute minimal set of features needed for a full TCP/IP stack \cite{contikiDoc, contikiUIP}.
In order to maximize the use of multichannel in improving packet delivery, routing topology plays a big role in providing an optimized routing tree to the network that is scalable and energy efficient. 
Routing protocol approaches can be classified into () types which are flat based and data centric, hierarchical, location based and network flow and quality of service (QoA) aware.

%Nodes closer to the sink need to handle more traffic than nodes in the perimeters.

\subsection{Classification of Routing Protocols}

\subsubsection{Flat based and Data Centric}

\subsubsection{Location Based}

\subsubsection{Network Flow and QoS-aware}

\subsubsection{Hierarchical}
\subsubsection*{CTP}
2 principles for wireless routing protocols; datapath validation - data traffic quickly discovers and fixes routing inconsistencies; adaptive beaconing - extending the Trickle algorithm to routing control traffic reduces route repair latency and sends fewer beacons. CTP Neo - an implementation of CTP.
Datapath validation actively uses data packets to validate the routing topology and detect loops. Each data packet contains the link-layer transmitter’s estimate of its distance. A node detects a possible routing loop when it receives a packet to forward from a node with a smaller or equal distance to the destination.
CTP is a routing protocol that computes anycast routes to a single or a small number of designated sinks in a wireless sensor network. CTP may appear very simple. They provide best-effort, unreliable, anycast packet delivery to one of the data sinks in the network. 
4 goals; reliability - a protocol should deliver at least 90% of end-to-end packets when a route exists. Robustness - should be able to operate without tuning or configuration in a wide range of network conditions, topologies, workloads and environments. Efficiency - should deliver packets with the minimum amount of transmissions. Hardware independence - without assuming specific radio chip features.
Rapid topology changes necessitate distance-vector rather than link-state algorithms. Simple distance-vector protocols however suffer from routing loops and other problems that harm reliability and efficiency. Link topology changes may result in transient loops which causes packet drops. A collection protocol builds and maintains minimum cost trees to nodes that advertise themselves as tree roots. Collection is address-free; when there are multiple base stations, it sends to the one with the minimum cost without knowing its address.
Every node maintains an estimate of the cost of its route to a collection point. ETX as the cost metric (any similar gradient metric can work just well). ETX does not effectively capture throughput. A node’s cost is the cost of its next hop plus the cost of its link to the next hop. The cost of a route is the sum of the costs of its links. Collection points advertise a cost of zero. Each data packet contains the transmitter’s local cost estimates. When a node receives a packet to forward, it compares the transmitter’s cost to its own. Cost must always decrease. 
When a timer interval expires, Trickle doubles it, up to a maximum value. When Trickle hears a newer version number, it shrinks the timer interval to a small value. Trickle enables quick discovery of new nodes and recovery from failures, while at the same time enabling long beacon intervals when the network is stable \cite{ctp}. 

CTP provides best effort anycast datagram communication to one of the collection roots in a network. A collection protocol delivers data to one of possibly several data sinks, providing many-to-one network layer. CTP uses routing frames to update and build collection tree in the network. CTP uses data frames to deliver application payload to the sink and to probe topology inconsistencies. 
	CTP is a tree-based collection protocol. Some nodes advertise as tree roots. Nodes form a set of routing trees to these roots. CTP is address free in that a node does not send a packet to a particular root, instead, it implicitly chooses a root by choosing a next hop. Nodes generate routes to roots using a routing gradient. CTP assumes that it has link quality estimates of some number of nearby neighbors (ETX). These provides an estimate of the number of transmissions it takes for the node to send a unicast packet whose acknowledgement is successfully received. 
CTP uses expected transmission (ETX) as its routing gradient. A root has an ETX of 0. ETX of a node is the ETX of its parent plus the ETX of its link to its parent. CTP should choose the one with the lowest ETX value. 
Problem is routing loops; occur when a node choose a new route that has a significantly higher ETX than its old one. CTP tries to resolve the inconsistency by broadcasting a beacon frame. Packet duplication - when a node receives a data frame successfully and transmit an ACK but ACK is not received. Thus CTP keeps a small cache of packet signature for the packets it has seen to detect packet duplicates.CTP data frames has additional time has lived (THL) field which the routing layer increments on each hop. Link-layer retransmission has the same THL.
If node’s ETX value changes significantly, CTP should transmit a broadcast frame to notify other nodes which might change their routes. A parent can detect when a child’s ETX is significantly below its own. When a parent hears a child advertise an ETX below its own, it must schedule a routing frame for transmission in the near future \cite{ctptep}.

**
Contiki Collect protocol and CTP are state-of-the-art address-free data collection protocols that provide a way for nodes to send data packets towards a data sink. Nodes do not need to know the address of the sink. Use ETX finding paths that minimize the number of packet transmissions to reach the root. Neither CTP nor Contiki Collect are IPv6-based. Contiki Collect uses the Contiki Rime stack \cite{beyondInteroperability}.

The data collection is an address-free protocol that sends messages towards a sink node somewhere in the network. The protocol is address-free in the sense that the originating nodes do not send their messages to a specific addressed node. Instead, the nodes send their messages towards the nearest sink in the network. The protocol does two things. It first builds a tree that originates at the sink nodes. The nodes build the tree by sending periodic announcements containing the number of hops away from the sink. After having built the tree, the nodes start sending messages towards the root of the tree. The protocol sends the messages using hop-by-hop reliable unicast \cite{rimes}. 

\subsubsection*{RPL}
The protocol makes use of IPv6 and supports not only traffic in the upwards direction, but also traffic flowing from a gateway node to all other network participants.
	RPL is a distance vector routing protocol that makes use of IPv6. A Destination Oriented Directed Acyclic Graph (DODAG) which is routed at a single destination is built. 
	The graph is constructed by the use of an Objective Function (OF) which defines how the routing metric is computed. OF specifies how routing constraints and other functions are taken into account during topology construction. The protocol tries to avoid routing loops by computing a node’s position relative to other nodes with respect to the DODAG root, called Rank and increases if nodes move away from the root and decreases when nodes move in the other direction. 
	RPL specification defines 4 types of control messages for topology maintenance and information exchange. DODAG Information Object (DIO) is the main source of routing control information. It may store information like the current Rank of a node, the current RPL Instance, the IPv6 address of the root, etc. Destination Advertisement Object (DAO) enables the support of down traffic and is used to propagate destination information upwards along the DODAG. DODAG Information Solicitation (DIS) makes it possible for a node to require DIO messages from a reachable neighbor. DAO-ACK (optional) is sent by a DAO recipient in response to a DAO message. RPL specification defines all 4 types of control messages as ICMPv6 information messages with a requested type of 155.
	RPL adapts the sending rate of DIO message by extending the Trickle algorithm.
	Upward routing is a standard procedure which enables network devices to send data to a common data sink, also called sometimes a gateway or root node. (BORDER ROUTER??!!)
	The Mode of Operation (MOP) field is set by the DODAG root 
	A DIO message may be extended by the use of options. DODAG Configuration option plays a crucial role for parameter exchange. MaxRankIncrease field defines an upper limit for the Rank. MinHopIncrease field stores the minimum increase of the Rank between a node and any of its parent nodes.
	3 types of nodes in a RPL network. 1. Root nodes which are commonly referred in literature as gateway nodes that provide connectivity to another network. 2. Routers which may advertise topology information to their neighbors. 3. Leafs that do not send any DIO messages and only have the ability to join an existing DODAG. 
	The construction of the topology starts at a root node that begins to send DIO messages. Each node that receives the message run an algorithm to choose an appropriate parent. The choice is based on the used metric and constraints defined by the OF. Afterwards, each of them computes its own Rank and in case a node is a router, it updates the Rank in the DIO message and sends it to all neighboring peers. *In most sensor node deployments several data collection points (root nodes) are needed.
	Whenever the sending timer expired, RPL doubles it up to the maximum value. Whenever RPL detects an event which indicates that the topology needs active maintenance, it resets the timer to minimum value. 
	Router nodes forward DIO control messages for topology maintenance - such messages are sent in a multicast manner to the neighboring nodes. RPL node does not process DIO messages from nodes deeper (higher Rank) than itself. 
	RPL metric - status includes typical resources such as CPU usage, available memory and left energy. Node energy consumption - node should consider the energy level of its neighbors before picking them as possible parents. RPL metric specification defines 3 possible states for the first information field: powered, on batteries and scavenger **** This may be a rough estimation of how much load a node experiences for a given period of time. ETX - is an approximation of the expected number of transmissions until a data packet reaches the gateway node*. A node that is one hop away from the root with perfect signal strength and very little interference may have ETX of 1. ETX is bidirectional single-hop link quality computation between 2 neighbor nodes.* A metric called Packet Reception Rate (PRR) is calculated at the receiver node for each window of received packets.
	Downward routing - by supporting P2MP traffic it is possible for a network administrator to control nodes that are even not in range. RPL specification defines 2 modes of operation for supporting P2MP. 1. Non-storing mode which makes use of source routing. In this mode each node has to propagate its parent list up to the root. After receiving such topology information, the root computes the path to the destinations. Each node has to extend the DAO message. After collecting the needed information, the root pieces the downward route together. If it needs to send a data packet to a given destination the IPv6 Source Routing header is used.  2. Storing mode which is fully stateful. Each non-root and non-leaf network participant has to maintain a routing table for possible destinations. DAO messages are used by RPL nodes to propagate routing information in order to enable P2MP traffic. DAO is no longer propagated to the DODAG root. Instead, it is sent as unicast to all parent nodes which maintain additional downward routing tables \cite{tsvetkov2011rpl}.
	
Routing protocol called RPL. RPL does not define any specific routing metrics, path costs or forwarding policies. RPL leaves this open so that different networks can apply different mechanisms to meet different objectives such as minimizing latency or minimizing energy consumption.
	ContikiRPL implementation of the RPL protocol which allows replaceable routing objective functions. ContikiRPL is the main IPv6 routing protocol in Contiki. RPL is a distance-vector protocol for IPv6 networks comprising low-power devices connected by lossy links. The protocol maintains Directed Acyclic Graph (DAG) topologies toward root nodes. The topologies are built proactively according to an objective function. It is flexible regarding the rules to form topologies and to select next-hops for individual packets. Routing decisions are taken by the objective function, which essentially specifies the constraints and metrics used in a network. 
	One objective function uses a simple hop count and one uses expected transmissions (ETX) to do the forwarding decision. The simple hop-count objective function results in a shorter path length at the expense of higher power consumption \cite{tsiftes_framework_2010}.
	
DIS - may be used to solicit a DIO from a RPL node. A node may use DIS to probe its neighborhood for nearby DODAGs.
DIO - carries information that allows a node to discover a RPL Instance, learn its configuration parameters, select a DODAG parent set and maintain the DODAG.
DAO - used to propagate destination information Upward along the DODAG. In Storing mode, the DAO message is unicast by the child to the selected parent(s). In Non-Storing mode, the DAO message is unicast to the DODAG root. The DAO message may optionally be acknowledged by its destination with a Destination Advertisement Acknowledgement (DAO-ACK) message back to the sender of the DAO. DAO-ACK message is sent as a unicast message packet by a DAO recipient (a parent or DODAG root) in response to a unicast DAO message \cite{winter2012rpl}.

RPL is a routing protocol that provides any-to-any routing in low-power Ipv6 networks, standardized by the IETF in March 2012. Its design is largely based on CTP, the reference data collection protocol for sensor networks. The RPL topology is a DODAG (Destination Oriented Directed Acyclic Graph) built in direction of the root, typically an access point to the Internet. Any-to-any traffic is routed first upwards, i.e. towards the root until a common ancestor of destination and source is found, and then downwards, following the nodes routing table. RPL uses a simple rooted topology instead of a full mesh; it is devoted to the maintenance of reliable paths to a single destination. The purpose of this strategy is to scale to large networks while containing the routing overhead, at the price of increased hop count (routing via a common ancestor). RPL terminology, the distance from a node to the root according to the routing metric is called rank. RPL requires sharing routing tables among siblings. In RPL, nodes propagate their routing entries through unicast (so-called DAO messages) to their parents. RPL’s rank hysteresis mechanism prevents nodes from switching parent for too little rank improvements. ContikiMAC – has wakeup consists of two clear channel assessments and has a phase-lock mechanism where senders record their neighbor’s wake-up phase and use it to make the next transmissions cheaper. *Experience an outage during which they cannot receive or send any data. This reflects for example scenarios where battery maintenance requires to disconnect a part of the network, or where external interference (e.g. WiFi or Bluetooth) affects communication. RPL experiences a sharp drop in the reliability during the first outage, consequence of failed MAC transmissions. Nodes react by switching parent, which heals the topology and slowly improves reliability. The next outages result in less churn (less agitate) \cite{orpl}.

////OBJECTIVE FUNCTION

////TRICKLE TIMER
A protocol uses Trickle to periodically advertise the most recent data it has received, typically through a version number. Routing control traffic - a protocol uses Trickle to control when it sends beacons that contain routing state.
Once the RPL network is established, it reduces the rate of control messages, exponential increase. To avoid control message explosion, nodes suppress transmissions if it hears too many messages from other - called the Trickle algorithm. 

Dynamically adjusting transmission windows allows Trickle to spread new information on the scale of link-layer transmission times while sending only a few messages per hour when information does not change.

To save energy the DIOs are sent periodically controlled by the trickle timer whose duration is doubled each time it is fired. The value of trickle timer starts from the lowest possible value lmin and is doubled each time it is transmitted until it reaches its maximum possible value of lmax \cite{trickle}.